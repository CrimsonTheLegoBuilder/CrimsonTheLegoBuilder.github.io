---
title: Font test
# date: 2023-10-29 16:00:00
categories:
- Tutorial
---

이 글은 폰트 테스트입니다.

```cpp
#include <iostream>
int main() {
    std::cout << "Hello, world!";
    return 0;
}
```


BOJ 13310 먼 별 C++

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>
typedef long long ll;
const ll MAX = 10'000'000'000'000'000;
struct Pos {
	ll x, y;
	bool operator<(const Pos& p) const { return x == p.x ? y < p.y : x < p.x; }
};
struct Vec { ll vx, vy; };
struct Star { ll x, y, vx, vy; };


ll cross(const Pos& d1, const Pos& d2, const Pos& d3, const Pos& d4) {
	return (d2.x - d1.x) * (d4.y - d3.y) - (d2.y - d1.y) * (d4.x - d3.x);
}
ll cross(const Pos& d1, const Pos& d2, const Pos& d3) {
	return (d2.x - d1.x) * (d3.y - d2.y) - (d2.y - d1.y) * (d3.x - d2.x);
}
ll cross(const Vec& v1, const Vec& v2) {
	return v1.vx * v2.vy - v1.vy * v2.vx;
}
ll cal_dist_sq(const Pos& d1, const Pos& d2) {
	return (d1.x - d2.x) * (d1.x - d2.x) + (d1.y - d2.y) * (d1.y - d2.y);
}
std::vector<Pos> pos_at_N(std::vector<Star>& P, int D) {
	std::vector<Pos> S;
	for (int i = 0; i < P.size(); i++) { S.push_back({ P[i].x + P[i].vx * D, P[i].y + P[i].vy * D }); }
	return S;
}
std::vector<Pos> monotone_chain(std::vector<Pos>& C) {
	std::vector<Pos> H;
	std::sort(C.begin(), C.end());
	if (C.size() <= 2) {
		for (const Pos& pos : C) H.push_back(pos);
		return H;
	}
	for (int i = 0; i < C.size(); i++) {
		while (H.size() > 1 && cross(H[H.size() - 2], H[H.size() - 1], C[i]) <= 0) {
			H.pop_back();
		}
		H.push_back(C[i]);
	}
	H.pop_back();
	int s = H.size() + 1;
	for (int i = C.size() - 1; i >= 0; i--) {
		while (H.size() > s && cross(H[H.size() - 2], H[H.size() - 1], C[i]) <= 0) {
			H.pop_back();
		}
		H.push_back(C[i]);
	}
	H.pop_back();
	return H;
}
//ll rotating_calipers(std::vector<Pos>& H) {
//	ll MD = 0;
//	int i = 0, f2i = 1, l = H.size();
//	for (i; i <= l; i++) {
//		while ((f2i + 1) % l != (i + 1) % l && cross(H[i % l], H[(i + 1) % l], H[f2i % l], H[(f2i + 1) % l]) > 0) {
//			if (MD < cal_dist_sq(H[i % l], H[f2i % l])) MD = cal_dist_sq(H[i % l], H[f2i % l]);
//			f2i++;
//		}
//		if (MD < cal_dist_sq(H[i % l], H[f2i % l])) MD = cal_dist_sq(H[i % l], H[f2i % l]);
//	}
//	return MD;
//}
Vec V(std::vector<Pos>& H, int i) {
	int f = (i + 1) % H.size();
	i %= H.size();
	return { H[f].x - H[i].x, H[f].y - H[i].y };
}
ll RC(std::vector<Pos>& H) {
	ll MD = 0;
	int f = 0, l = H.size();
	for (int i = 0; i < l; i++) {
		while (cross(V(H, i), V(H, f)) > 0) {
			MD = std::max(MD, cal_dist_sq(H[i], H[f]));
			f = (f + 1) % l;
		}
		MD = std::max(MD, cal_dist_sq(H[i], H[f]));
	}
	return MD;
}
Pos ternary_search(std::vector<Star>& stars, int X) {
	if (X < 7) return { 0, X + 1 };
	int s = 0, e = X;
	int l, r;
	std::vector<Pos> SL, SR, HL, HR;
	ll DL, DR;
	while (e - s >= 3) {
		l = (s * 2 + e) / 3;
		r = (s + e * 2) / 3;
		//SL = pos_at_N(stars, l); HL = monotone_chain(SL); DL = rotating_calipers(HL);
		//SR = pos_at_N(stars, r); HR = monotone_chain(SR); DR = rotating_calipers(HR);
		SL = pos_at_N(stars, l); HL = monotone_chain(SL); DL = RC(HL);
		SR = pos_at_N(stars, r); HR = monotone_chain(SR); DR = RC(HR);
		if (DL > DR) s = l;
		else e = r;
	}
	return { s, e + 1 };
}
Pos get_min(std::vector<Star>& stars, int X) {
	Pos days = ternary_search(stars, X);
	int mind = 0;
	ll MIN = MAX, MD;
	std::vector<Pos> S, H;
	for (int i = days.x; i < days.y; i++) {
		S = pos_at_N(stars, i);
		H = monotone_chain(S);
		MD = RC(H);
		if (MIN > MD) {
			MIN = MD; mind = i;
		}
	}
	return { mind, MIN };
}



int main() {
	std::cin.tie(0)->sync_with_stdio(0);
	std::cout.tie(0);
	int N, T, x, y, vx, vy;
	std::vector<Star> stars;
	Pos min_day;
	std::cin >> N >> T;
	for (int i = 0; i < N; i++) {
		std::cin >> x >> y >> vx >> vy;
		stars.push_back({ x, y, vx, vy });
	}
	min_day = get_min(stars, T);
	std::cout << min_day.x << "\n" << min_day.y << "\n";
	return 0;
}
```


```python
import sys
input = sys.stdin.readline


def cr(d1, d2, d3, d4):  # cross product / get CCW / get Torque / get area
    return (d2[0]-d1[0])*(d4[1]-d3[1]) - (d2[1]-d1[1])*(d4[0]-d3[0])


def cd(a1, a2):  # get c^2 = a^2 + b^2
    return (a1[0]-a2[0])**2 + (a1[1]-a2[1])**2


def mc(arr):  # get hull
    arr.sort(key=lambda x: (x[0], x[1]))
    if len(arr) <= 2:
        return arr
    lh = []
    for dl in arr:
        while len(lh) > 1 and cr(lh[-2], lh[-1], lh[-1], dl) <= 0:
            lh.pop()
        lh.append(dl)
    uh = []
    for du in reversed(arr):
        while len(uh) > 1 and cr(uh[-2], uh[-1], uh[-1], du) <= 0:
            uh.pop()
        uh.append(du)
    return lh[:-1] + uh[:-1]


def rc(h):  # get max distance of hull
    b = 1
    l = len(h)
    mx_d = 0
    for a in range(l + 1):
        while (b + 1) % l != a % l and cr(h[a % l], h[(a+1) % l], h[b % l], h[(b+1) % l]) > 0:
            if mx_d < cd(h[a % l], h[b % l]):
                mx_d = cd(h[a % l], h[b % l])
            b += 1
        if mx_d < cd(h[a % l], h[b % l]):
            mx_d = cd(h[a % l], h[b % l])
    return mx_d


def px(tp, x):  # compose list of positions at day x
    p_x = [(i[0] + i[2]*x, i[1] + i[3]*x) for i in tp]
    return p_x


def ts(d, x):  # get range of days during which the maximum length of the hull becomes smaller
    if x < 7:
        return (i for i in range(0, x + 1, 1))
    s, e = 0, x
    while e - s >= 3:
        l = (s*2 + e) // 3  # 1/3
        r = (s + e*2) // 3  # 2/3
        ml = rc(mc(px(d, l)))
        mr = rc(mc(px(d, r)))
        if ml > mr:
            s = l
        else:
            e = r
    return (i for i in range(s, e + 1, 1))


def gm(d, x):  # find min length of hulls and min day after ternary search
    ml = int(1e16)
    md = 0
    for i in x:
        mxi = rc(mc(px(d, i)))
        if ml > mxi:
            ml = mxi
            md = i
    return md, ml


n, t = map(int, input().split())
S = [tuple(map(int, input().split())) for _ in range(n)]
A = gm(S, ts(S, t))
print(A[0])
print(A[1])

'''
example

10 1000000
1 1 5 5
5 5 -1 1
2 3 2 3
4 3 5 6
6 5 4 3
3 3 -1 -1
6 9 -1 -2
7 8 -2 -4
0 0 10 0
-2 -3 -4 5

8 100
1 1 0 0
2 2 -1 0
3 4 1 0
5 4 -3 4
6 7 9 -1
0 3 3 3
2 0 -3 -3
1 0 2 1

10 100
50 60 -5 -5
50 50 -1 -1
20 30 -2 -3
40 30 -5 -6
-60 -50 4 3
-15 -30 1 1
60 90 -5 -6
70 80 -2 -4
0 0 7 0
-20 -30 4 5
'''

```


BOJ 10830

```cpp
#include <iostream>
typedef long long ll;
const ll MOD = 1000;

struct M {
	int** m;
	int r, c;
	M(int r, int c) : r(r), c(c) {  //default constructor
		m = new int* [r];
		for (int i = 0; i < r; i++) {
			m[i] = new int[c];
			for (int j = 0; j < c; j++) {
				m[i][j] = 0;
			}
		}
	}
	M(const M& R) :r(R.r), c(R.c) {  //copy constructor
		m = new int* [r];
		for (int i = 0; i < r; i++) {
			m[i] = new int[c];
			for (int j = 0; j < c; j++) {
				m[i][j] = R.m[i][j];
			}
		}
	}
	~M() {  //destructor
		//std::cout << "destruct\n";
		for (int i = 0; i < r; i++) {
			delete[] m[i];
		}
		delete[] m;
	}
	M operator * (const M& R) const {  //overloading
		M p(r, R.c);
		for (int i = 0; i < r; i++) {
			for (int j = 0; j < R.c; j++) {
				for (int k = 0; k < c; k++) {
					p.m[i][j] += m[i][k] * R.m[k][j];
					p.m[i][j] %= MOD;
				}
			}
		}
		return p;
	}
	M& operator = (const M& R) {  //copy assignment operator
		if (this == &R) return *this;
		for (int i = 0; i < r; i++) {
			delete[] m[i];
		}
		delete[] m;
		r = R.r; c = R.c;
		m = new int* [r];
		for (int i = 0; i < r; i++) {
			m[i] = new int[c];
			for (int j = 0; j < c; j++) {
				m[i][j] = R.m[i][j];
			}
		}
		return *this;
	}
};
M pow_m(M A, ll B) {  //divide & conquer
	if (B <= 1) return A;
	ll b = B >> 1;
	M A_ = pow_m(A, b);
	if (B % 2) return A_ * A_ * A;
	else return A_ * A_;
}


int main() {
	int n;
	ll B;
	std::cin >> n >> B;
	M A(n, n);
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			std::cin >> A.m[i][j];
		}
	}
	//for (int i = 0; i < n; i++) {
	//	for (int j = 0; j < n; j++) {
	//		std::cout << A.m[i][j] << " ";
	//	}
	//	std::cout << "\n";
	//}
	M C(n, n);
	for (int i = 0; i < n; i++) C.m[i][i] = 1;

	//while (B--) {
	//	C = C * A;
	//}
	//for (int i = 0; i < n; i++) {
	//	for (int j = 0; j < n; j++) {
	//		std::cout << C.m[i][j] << " ";
	//	}
	//	std::cout << "\n";
	//}
	C = pow_m(A, B);
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			std::cout << C.m[i][j]%1000 << " ";
		}
		std::cout << "\n";
	}
	return 0;
}
```
